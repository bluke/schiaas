/*! 
@mainpage SCHIaaS Documentation

SCHIaaS allows to simulate IaaS with SimGrid.

While SimGrid implements hypervisor level functionalities (e.g. start and stop VMs),
SCHIaaS implements cloud level functionalities (e.g. run and terminate instances).

It supports main VM management functions:
- run, terminate, suspend, resume and describe instances;
- description of available resources;
- image and instance types management;
- automatic VM placement on the clusters (in a round-robin way);
- boot and other VM life-cycle processes;
- cloud storage management.

For now, it does not support other cloud functionalities, such as network management.

SchIaaS is an improved interface: every operation is actually handle by an engine. This allows SchIaaS applications to be compatible with any cloud internals, or even use different internals together in a multi-cloud context.

For now, two engines are available and fully functional:
- RICE: Reduced Implementation of Compute Engine
- RISE: Reduced Implementation of Storage Engine

@section running Running SCHIaaS

@subsection running_prerequisite Prerequisite

SCHIaaS runs upon <a href="http://simgrid.gforge.inria.fr/">SimGrid</a>.
Make sure to enable Java support:
@code
git clone git://scm.gforge.inria.fr/simgrid/simgrid.git
cd simgrid
cmake -Denable_java=on .
make
sudo make install
@endcode
You can also get the Simgrid jar from the <a href="http://simgrid.gforge.inria.fr/">simgrid website</a>. 
Make sure to have at least version 3.11


@subsection running_retrieving Retrieving and Installing Schiaas

The last version of SCHIaaS can be retrieved from the git repository :
@code
git clone https://gforge.inria.fr/git/schiaas/schiaas.git
or
git clone git://scm.gforge.inria.fr/schiaas/schiaas.git
@endcode
Please note the code is still unstable.

Afterward, you can build SCHIaaS:
@code
cd schiaas
cmake .
make
@endcode

If cmake complains about the location simgrid.jar, make sure to set SIMGRID_JAR_PATH:
@code
export SIMGRID_JAR_PATH=/path/to/simgrid.jar/
@endcode
For instance:
@code
export SIMGRID_JAR_PATH=/usr/local/java/
@endcode

Then you should have schiaas.jar inside the bin directory, which you can use to develop your own application.



You may also get a pre-compiled schiaas.jar <a href="./schiaas.jar">here</a>. Note that this jar was last updated at the same time has this doc.


@section tutorial Tutorial: the master-slave example

This tutorial assume that you have already followed the SimGrid's Java MSG master-slave example. 

Instead of declaring slaves into the deployment file, 
this tutorial shows how to deploy slaves instances on the fly.

@subsection tutorial_setup Simulation setup

First of all, the platform file does not need to be modified.

Second, the deployment file does not need to include slave processes placement anymore, 
as slaves processes will be binded to instances at runtime.

Last, a new configuration file is introduced to declare cloud configuration, cloud.xml:
@code
<?xml version='1.0'?>
 <!DOCTYPE clouds>
 <clouds version="1">
	<cloud  id="myCloud">
		
		<storage id="myStorage" engine="org.simgrid.schiaas.engine.rise.Rise">
			<config controller="Jacquelin"/>
		</storage>

		<compute engine="org.simgrid.schiaas.engine.rice.Rice"> 
		
			<config controller="Jacquelin" 
					image_storage="myStorage" image_caching="PRE"
					inter_boot_delay="10"/>
			
			<instance_type id="small" core="1" memory="1000" disk="1690"/>				
			<instance_type id="medium" core="2" memory="1000" disk="1690"/>
			<instance_type id="large" core="4" memory="1000" disk="1690"/>
			
			<image id="myImage" size="1073741824"/>
		
			<host id="Boivin"/>
			<host id="Jean_Yves"/>
			<host id="TeX"/>
			<host id="Geoff"/>
			<host id="Disney"/>
			<host id="iRMX"/>
			<host id="McGee"/>
			<host id="Gatien"/>
			<host id="Laroche"/>
			<host id="Tanguay"/>
			<host id="Morin"/>
			<host id="Ethernet"/>
			<host id="Bellemarre"/>
			<host id="Kuenning"/>
			<host id="Gaston"/>
			<host id="Harry"/>
		</compute>
	</cloud>
</clouds> 
@endcode

Cloud files are validated using <a href="./cloud.xsd">cloud.xsd</a> found in the schiaas sources.

@subsubsection cloud_tag Cloud tag

The cloud tag must have the following attributes:
- id: the id of the cloud or of the region;

You can declare as many clouds as needed, and clouds can also used to model regions.

Inside the cloud element, you must define storage and compute.


@subsubsection storage_tag Storage tag

The storage tag must have the following attributes:
- id: the id of the storage;
- engine: the engine of the storage;

It also must include one config tag, giving any information needed by this engine. For instance, RICE only needs one controller, which will store and distribute the data.

As many storages as needed can be declared, and they must be declared before the compute tag. 


@subsubsection compute_tag Compute tag

The compute tag must have the following attributes:
- engine: the engine of the compute;

It must also include the following tags:

- config: any information needed by this engine. For instance, RISE needs: 
  - one controller, which will distribute the commands; 
  - an image_storage; an image_caching strategy, that can be ON, OFF, or PRE; 
  - an inter_boot_delay, that is the delay between two consecutive VM boots on one given host.

- instance_type, having some attributes discribing the type of instance;

- image, having two attributes:
  - id;
  - size;

- host or cluster, to declare the hosts usable to run instance.


@subsection tutorial_code Java Code

@subsubsection tutorial_initialization Initialization

In order to initialize SCHIaaS, you must use SchIaaS.init(), its argument being the cloud configuration file. This is typically done in Masterslave.java:
@code
import org.simgrid.schiaas.SchIaaS;
[...]

	/* construct the platform and deploy the application */
	Msg.createEnvironment(args[0]);
	Msg.deployApplication(args[1]);
	
	/* construct the cloud and deploy the associated processes */
	SchIaaS.init(args[2]);

	/*  execute the simulation. */
    Msg.run();
@endcode


@subsubsection tutorial_instance Instances management

The main modification concernes Master.java, which must declare an instance image and run one instance per slave:
@code
import org.simgrid.schiaas.*;
[...]
	Msg.info("Hello! Got "+  slavesCount + " slaves and "+tasksCount+" tasks to process");
	// Retrieve the Compute module of MyCloud
	Compute myCompute = SchIaaS.getCloud("myCloud").getCompute();
	
	// Run one instance per slave on myCloud
	String[] slaveInstancesId = myCompute.runInstances("myImage", "small", slavesCount);
@endcode
Afterward, slaveInstancesId constains instances' id, which are the name of SimGrid's VMs and can be used just like any SimGrid host.

Please note that if you ask for more instances than your cloud can provide, runInstances and runInstance will return null. Careful users will check how many instances can be ran:
@code
for (InstanceType instanceType : myCompute.describeInstanceTypes()) {
			Msg.info(instanceType.getId()+ ": "
					+ myCompute.describeAvailability(instanceType.getId()));
		}
@endcode

Before using theses instances, you must wait for the end of their boot process,
otherwise, the binded processes will start immediately and concurrently to the boot process, mistaking both your process running date and the boot duration.
Then, you can bind the slave process to the running instance:
@code
for (int i=0; i<slavesCount; i++) {
	Msg.info("waiting for boot");
	while (myCompute.describeInstance(slaveInstancesId[i]).isRunning() == 0) {
		waitFor(10);
	}
	
	Msg.info("Starting a slave on "+myCompute.describeInstance(slaveInstancesId[i]).getName());
	String [] slaveArgs = {""+i};
	Slave s = new Slave(myCompute.describeInstance(slaveInstancesId[i]),
						"slave_"+i,slaveArgs);
	s.start();
}
@endcode

During the execution, you can suspend and resume instances:
@code
waitFor(150);
Msg.info("Suspending " + slaveInstancesId[0]);
myCompute.suspendInstance(slaveInstancesId[0]);
waitFor(200);
Msg.info("Resuming " + slaveInstancesId[0]);
myCompute.resumeInstance(slaveInstancesId[0]);
@endcode

Finally, you can terminate instances one by one:
@code
myCompute.terminateInstance(oneInstanceId);
@endcode

Then, you have to terminate SchIaaS to clean-up the simulation:
@code
SchIaaS.terminate();
@endcode
Please note that this will also terminate all the instances that are still running.

@subsubsection tutorial_data Data management

You can also manipulate some data:
@code
Storage myStorage = SchIaaS.getCloud("myCloud").getStorage("myStorage");

Data someData = new Data("someData", 1e9);

Msg.info("Store some data");
myStorage.put(someData);

Msg.info("Check whether the data transfer is complete: " +
		myStorage.isTransferComplete("someData"));

Msg.info("Retrieve some stored data");
someData = myStorage.get("someData");

Msg.info("Retrieve some data that has not been stored");
Data unstoredData = new Data("unstoredData", 2e9);
someData = myStorage.get(unstoredData);

Msg.info("List the stored data");
Map <String, Data> storedData = myStorage.list(); 	//1st way
myStorage.ls();										//2d way

Msg.info("Delete some data");
myStorage.delete("someData");
@endcode


@subsubsection tutorial_reports Reports

And last, you can obtain cloud usage report by modifying Masterslave.java:
@code
/* execute the simulation */
Msg.run();        

/* print cloud reports */
Msg.info("Cloud details\n");
for (Cloud cloud : SchIaaS.getClouds())  {
	Msg.info("Cloud:"+cloud.getId());
	for (Instance instance : cloud.getCompute().describeInstances()) {
		Msg.info(" - "+instance);
	}
}s
@endcode


@subsubsection tutorial_running Running the cloudmasterslave example

In order to build and run this example, you must add simgrid.jar and schiaas.jar to the jvm classpath:
@code
cd schiaas/bin/cloudmasterslave
java -cp /usr/local/java/simgrid.jar:../schiaas.jar:cloudmasterslave.jar cloudmasterslave.Masterslave platform.xml deploy.xml cloud.xml
@endcode

*/
