/*! 
@mainpage SchIaaS Documentation

SchIaaS allows to simulate IaaS with SimGrid.

While SimGrid implements hypervisor level functionalities (e.g. start and stop VMs),
SchIaaS implements cloud level functionalities (e.g. run and terminate instances).

It supports main VM management functions:
- run, terminate, suspend, resume and describe instances;
- description of available resources;
- image and instance types management;
- automatic VM placement on the clusters (in a round-robin way);
- boot and other VM life-cycle processes;
- cloud storage management.

For now, it does not support other cloud functionalities, such as network management.

SchIaaS is an improved interface: every operation is actually handle by an engine. 
This allows SchIaaS applications to be compatible with any cloud internals, or even use different internals together in a multi-cloud context.

For now, two engines are available and fully functional:
- RICE: Reduced Implementation of Compute Engine
- RISE: Reduced Implementation of Storage Engine

@section running Running SchIaaS

@subsection running_prerequisite Prerequisite

SchIaaS runs upon <a href="http://simgrid.gforge.inria.fr/">SimGrid</a>.
Make sure to enable Java support:
@code
git clone git://scm.gforge.inria.fr/simgrid/simgrid.git
cd simgrid
cmake -Denable_java=on .
make
sudo make install
@endcode
You can also get the Simgrid jar from the <a href="http://simgrid.gforge.inria.fr/">simgrid website</a>. 
Make sure to have at least version 3.11


@subsection running_retrieving Retrieving and Installing Schiaas

The last version of SchIaaS can be retrieved from the git repository :
@code
git clone https://gforge.inria.fr/git/schiaas/schiaas.git
or
git clone git://scm.gforge.inria.fr/schiaas/schiaas.git
@endcode
Please note the code is still unstable.

Afterward, you can build SchIaaS:
@code
cd schiaas
cmake .
make
@endcode

If cmake complains about the location simgrid.jar, make sure to set SIMGRID_JAR_PATH:
@code
export SIMGRID_JAR_PATH=/path/to/simgrid.jar/
@endcode
For instance:
@code
export SIMGRID_JAR_PATH=/usr/local/java/
@endcode

The build produces a schiaas.jar file in the bin/ directory under the current working directory. 

This schiaas.jar is to be added to the list of the java and jar files of your own programs when compiling, as shown in the \ref tutorial_running. 



You may also get a pre-compiled schiaas.jar <a href="./schiaas.jar">here</a>. Note that this jar was last updated at the same time has this doc.






@section tracing Tracing

@subsection tracing_description Description

SCHIaaS comes with its own tracing system. It is described in <a href="./javadoc/schiaas/org/simgrid/schiaas/tools/Trace.html">the javadoc</a>.

It handle two kind of information: **events** (with date) and **properties** (without date). Each information is related to one entity.

All lines of the trace are of the form:
@code
entity	key	value
@endcode
In which **key** being either the *date* for **event**, or the *name* for **properties**.

For instance, the traces have this form:
@code
root    date    Tue Nov 10 16:23:40 CET 2015
root:cloud:myCloud:compute:compute_host:node-1.me        cores   8.0
root:cloud:myCloud:compute:compute_host:node-1.me:used_cores     0.0     5.0
@endcode
Give the following information:
- (property) *date* and *description* of the simulation;
- (property) *8.0*, the number of *cores* of the *compute_host* named *node-1.me* in the *compute* of the *cloud* named *myCloud*;
- (event) *5.0*, the number of *used_cores* of this host at t=*0.0* 

The trace is sorted by date and can be easily filtred using grep.

It can also be exploited using the script *trace-util.py*, located in the *lab/bin* directory (see \ref tracing_examples).


@subsection tracing_tutorial Tracing your own code

Let's say you want to trace something called *mystuff*.

@subsubsection tracing_tutorial_init Intialization and conclusion

If you want to add a description to the whole trace, you can use:
@code
Trace.init("description of the whole trace");
@endcode

This step is optional. However, the conclusion step is mandatory:
@code
Trace.close();
@endcode


@subsubsection tracing_tutorial_creation Creating 

First of all, you need to create the trace. 
- If *mystuff* is unique :
@code
Trace trace = Trace.newTrace("mystuff");
@endcode
- If *mystuff* is one of a kind:
@code
Trace trace = Trace.newCategorizedTrace("kind_of_mystuff","mystuff");
@endcode
- If *mystuff* is related to a higher level entity:
@code
Trace trace = parentTrace.newSubTrace("mystuff");
@endcode
@code
Trace trace = parentTrace.newCategorizedSubTrace("kind_of_mystuff","mystuff");
@endcode


@subsubsection tracing_tutorial_properties Adding properties

To add one property to *mystuff*, for instance the name, you can use:
@code
trace.addProperty("name", "the name of mystuff");
@endcode

According to the type of trace, this will produce one of the following line (3 fields, separated by tabulations):
@code
root:mystuff 	name 	the name of mystuff
@endcode
@code
root:kind_of_mystuff:mystuff 	name 	the name of mystuff
@endcode
@code
root:[parent]:mystuff 	name 	the name of mystuff
@endcode
@code
root:[parent]:kind_of_mystuff:mystuff 	name 	the name of mystuff
@endcode
where [parent] is the chain of entities from the parent trace.

You can also add one whole set of properties:
@code
trace.addProperties(properties);
@endcode
where *properties* is a *Map<String,String>*.


@subsubsection tracing_tutorial_events Adding events

To add one event to *mystuff*, for instance the *state* becoming *available*, you can use:
@code
trace.addEvent("state", "available")
@endcode
This will produce one line (3 fields, separated by tabulations):
@code
[prefix]:mystuff:state 	832.0	available
@endcode
where *832.0* is the clock of the simulation, and [prefix] depending on the type of trace, like in \ref tracing_tutorial_properties .



@subsection tracing_examples Some examples of use of trace-util.py

@subsubsection tracing_examples_info Retrieving the available entities
@code
$ ./trace-util.py schiaas.trace --info

{
  "root": {
    "date": "property",
    "description": "property",
    "cloud": {
      "myCloud": {
        "compute": {
          "image_caching": "property",
          "inter_boot_delay": "property",
          "engine": "property",
          "image_storage": "property",
          "controller": "property",
          "compute_host": {
            "* x24": {
              "cores": "property",
              "ram_size": "property",
              "diskSize": "property",
              "used_cores": "event"
            }
          },
          "scheduler": {
            "name": "property",
            "delay": "property",
            "controller": "property",
            "type": "property"
          },
          "instance": {
            "* x465": {
              "image": "property",
              "instance_type": "property",
              "command": "event",
              "schedule": "event",
              "load": "event"
            }
          }
        }
      }
    },
    "VirtualMachines": {
      "* x465": {
        "n_cores": "property",
        "ram_size": "property",
        "net_cap": "property",
        "disk_path": "property",
        "disk_size": "property",
        "mig_net_speed": "property",
        "dp_intensity": "property",
        "cpu_bound": "event",
        "state": "event"
      }
    },
    "injector": {
      "myInjector": {
        "injector": "property",
        "random_seed": "property",
        "instances_count": "event",
        "instances_load": "event"
      }
    }
  }
}
@endcode
This show every entities, properties, and events available in the trace.
Entities of the same type are compacted as "* xCOUNT".
For instance, this trace contains *465* virtual machines and theirs number of cores can be filtered using the regex *VirtualMachines.\*n_cores*.

@subsubsection tracing_examples_json Dumping the whole trace as a json
@code
$ ./trace-util.py schiaas.trace --json

{
  "root": {
    "date": "Tue Nov 10 16:23:40 CET 2015",
    "description": "Example of LoadInjector on cloud",
    "cloud": {
      "myCloud": {
        "compute": {
          "compute_host": {
            "node-1.me": {
              "cores": "8.0",
              "used_cores": {
                "0.0": "0.0,1.0,2.0,3.0,4.0,5.0",
...
@endcode
NB: all the events of the same type and attached to the same entity that occured at the same date are concatenated in the same entry, ordered by occuring date in the simulator.

For instance, this json shows that at *date* 0.0, the *used_cores* of *node-1.me* had its value from 0.0 to 5.0, 5.0 being the last one.

@subsubsection tracing_examples_event Looking at the used_cores values
@code
$ ./trace-util.py schiaas.trace --event used_cores

root:cloud:myCloud:compute:compute_host:node-2.me:used_cores	0.0	5.0
root:cloud:myCloud:compute:compute_host:node-3.me:used_cores	0.0	5.0
root:cloud:myCloud:compute:compute_host:node-1.me:used_cores	0.0	5.0
root:cloud:myCloud:compute:compute_host:node-2.me:used_cores	180.0	6.0
root:cloud:myCloud:compute:compute_host:node-3.me:used_cores	180.0	6.0
root:cloud:myCloud:compute:compute_host:node-1.me:used_cores	180.0	6.0
...
@endcode
This shows that at date *0.0*, the *used_cores* of *node-1.me*, *node-2.me* and *node-3.me* were *5.0*, while they were *6.0* at date *180.0*

@subsubsection tracing_examples_event2 Looking at the used_cores values of node-1
@code
$ ./trace-util.py schiaas.trace --event node-1\.me.*used_cores

root:cloud:myCloud:compute:compute_host:node-1.me:used_cores	0.0	5.0
root:cloud:myCloud:compute:compute_host:node-1.me:used_cores	180.0	6.0
root:cloud:myCloud:compute:compute_host:node-1.me:used_cores	410.0	7.0
root:cloud:myCloud:compute:compute_host:node-1.me:used_cores	680.0	8.0
...
@endcode
This shows that the *used_cores* of *node-1.me* goes from *5.0* to *8.0* at the dates *0.0*, *180.0*, *410.0* and *680.0*.

@subsubsection tracing_examples_counting counting the nodes having less than 8 cores used
@code
$ ./trace-util.py schiaas.trace --count-if used_cores lt 8

used_cores	0.0	24
used_cores	2830.0078070824743	23
used_cores	2920.0078070824743	22
used_cores	2930.0078070824743	21
...
@endcode
This shows that at date *0.0*, *24* nodes had less than 8 cores used, and the following changes of this value.

@subsubsection tracing_examples_counting2 counting the virtual machines in the migrating state
@code
$ ./trace-util.py schiaas.trace --count-if VirtualMachines.*state eq migrating

used_cores	0.0	0
used_cores	2830.0078070824743	1
used_cores	2920.0078070824743	2
used_cores	2930.0078070824743	3
...
@endcode
This shows that at date *0.0*, *0* virtual machines were migrating, and the following changes of this value.







@section tutorial Tutorial: the master-slave example

@subsection tutorial_overview Overview of the Example


For a better understanding of this tutorial we recommend that you read the SimGrid's Java MSG master-slave example. 
The following is essentially a summary of the differences between the SimGrid's way of describing a master-slave computation
and the SchIaaS's one.
The main difference between this cloud scenario and the original SimGrid example lies in the 
fact that slave instances are deployed on the fly, while in the original SimGrid example, 
slaves to launch were statically declared in the deployment configuration.


Recall that setting up this example requires :
- configuration (XML) files to describe the environment and the mapping of processes to hosts  
- Java programs to describe the behavior of the processes: 
	- **Masterslave.java** is the orchestrator: it reads the configuration files and runs the simulation
	- **Master.java** describes the Master process's behavior: 
   it creates a number of slave processes specified in the deployement configuration file, and do clever things with slave processes.
   In the SimGrid Masterslave example, the master is just sending data to slaves, while we demonstrate additional cloud-related features like 
   migration of VM in this SchIaaS example.
	- **Slave.java**: the Slave behavior (unchanged from simGrid example) which simply receives data from the Master.

These files can be found in the distribution under *examples/cloudmasterslave/*



@subsection tutorial_setup Simulation setup

Recall that SimGrid uses a *platform file* to describe the set of all hardware devices available,
and a *deployment file* to tell onto which of these devices the different processes run. 
An example platform file is <a href="../../examples/cloudmasterslave/companionFiles/platform.xml">here</a>.

 
For a schiaas simulation, the platform file is the one you would normally use for a SimGrid simulation. 
The deployment file is also similar excepted that it does not need to include the placement of slave processes anymore, as slaves processes will be binded to instances at runtime.
Below is an example of deployment description, where we specify that the *Master* process runs on host *Jacquelin*.
@code
<?xml version='1.0'?>
<!DOCTYPE platform SYSTEM "http://simgrid.gforge.inria.fr/simgrid.dtd">
<platform version="3">
  <!-- The master process (with some arguments) -->

  <process host="Jacquelin" function="cloudmasterslave.Master">
     <argument value="10"/>       <!-- Number of tasks -->
     <argument value="5e10"/>  <!-- Computation size of tasks -->
     <argument value="1000000"/>   <!-- Communication size of tasks -->
     <argument value="10"/>  <!-- Number of masterslave.Slaves -->
  </process>

</platform>
@endcode

Last, a new configuration file is introduced to declare cloud configuration, cloud.xml:
@code
<?xml version='1.0'?>
 <!DOCTYPE clouds>
 <clouds version="1">
	<cloud  id="myCloud">
		
		<storage id="myStorage" engine="org.simgrid.schiaas.engine.rise.Rise">
			<config controller="Jacquelin"/>
		</storage>

		<compute engine="org.simgrid.schiaas.engine.rice.Rice"> 
		
			<config controller="Jacquelin" 
					image_storage="myStorage" image_caching="PRE"
					inter_boot_delay="10"/>
			
			<instance_type id="small" core="1" memory="1000" disk="1690"/>				
			<instance_type id="medium" core="2" memory="1000" disk="1690"/>
			<instance_type id="large" core="4" memory="1000" disk="1690"/>
			
			<image id="myImage" size="1073741824"/>
		
			<host id="Boivin"/>
			<host id="Jean_Yves"/>
			<host id="TeX"/>
			<host id="Geoff"/>
			<host id="Disney"/>
			<host id="iRMX"/>
			<host id="McGee"/>
			<host id="Gatien"/>
			<host id="Laroche"/>
			<host id="Tanguay"/>
			<host id="Morin"/>
			<host id="Ethernet"/>
			<host id="Bellemarre"/>
			<host id="Kuenning"/>
			<host id="Gaston"/>
			<host id="Harry"/>
		</compute>
	</cloud>
</clouds> 
@endcode

Cloud files are validated using <a href="./cloud.xsd">cloud.xsd</a> found in the schiaas sources.

@subsubsection cloud_tag Cloud tag

The cloud tag must have the following attributes:
- id: the id of the cloud or of the region;

You can declare as many clouds as needed, and clouds can also used to model regions.

Inside the cloud element, you must define storage and compute.


@subsubsection storage_tag Storage tag

The storage tag must have the following attributes:
- id: the id of the storage;
- engine: the engine of the storage;

It also must include one config tag, giving any information needed by this engine. For instance, RICE only needs one controller, which will store and distribute the data.

As many storages as needed can be declared, and they must be declared before the compute tag. 


@subsubsection compute_tag Compute tag

The compute tag must have the following attributes:
- engine: the engine of the compute;

It must also include the following tags:

- config: any information needed by this engine. For instance, RISE needs: 
  - one controller, which will distribute the commands; 
  - an image_storage; an image_caching strategy, that can be ON, OFF, or PRE; 
  - an inter_boot_delay, that is the delay between two consecutive VM boots on one given host.

- instance_type, having some attributes discribing the type of instance;

- image, having two attributes:
  - id;
  - size;

- host or cluster, to declare the hosts usable to run instance.


@subsection tutorial_code Java Code

@subsubsection tutorial_initialization Initialization

As previously explained, we need an orchestrator to read and setup the environment. 
This is the *Masterslave.java* file in this example. 
In addition, it has to initialize SchIaaS though SchIaaS.init(), its argument being the cloud configuration file. 
@code
import org.simgrid.schiaas.SchIaaS;
[...]

	/* construct the platform and deploy the application */
	Msg.createEnvironment(args[0]);
	Msg.deployApplication(args[1]);
	
	/* construct the cloud and deploy the associated processes */
	SchIaaS.init(args[2]);

	/*  execute the simulation. */
	Msg.run();
@endcode


@subsubsection tutorial_instance Instances management

*Master.java* controls the application launch. Given that we simulate virtualization through VM images, *Master.java*
contains a couple of changes as compared to the original Master.java of SimGrid.
It must declare an instance image and run one instance per slave:

@code
import org.simgrid.schiaas.*;
[...]
	Msg.info("Hello! Got "+  slavesCount + " slaves and "+tasksCount+" tasks to process");
	// Retrieve the Compute module of MyCloud
	Compute myCompute = SchIaaS.getCloud("myCloud").getCompute();
	
	// Run one instance per slave on myCloud
	String[] slaveInstancesId = myCompute.runInstances("myImage", "small", slavesCount);
@endcode
Afterwards, slaveInstancesId constains instances' id, which are the name of SimGrid's VMs and can be used just like any SimGrid host.

Please note that if you ask for more instances than your cloud can provide, runInstances and runInstance will return null. Careful users will check how many instances can be ran:
@code
for (InstanceType instanceType : myCompute.describeInstanceTypes()) {
			Msg.info(instanceType.getId()+ ": "
					+ myCompute.describeAvailability(instanceType.getId()));
}
@endcode

Before using theses instances, you must wait for the end of their boot process,
otherwise, the binded processes will start immediately and concurrently to the boot process, mistaking both your process running date and the boot duration.
Then, you can bind the slave process to the running instance:
@code
for (int i=0; i<slavesCount; i++) {
	Msg.info("waiting for boot");
	while (myCompute.describeInstance(slaveInstancesId[i]).isRunning() == 0) {
		waitFor(10);
	}
	
	Msg.info("Starting a slave on "+myCompute.describeInstance(slaveInstancesId[i]).getName());
	String [] slaveArgs = {""+i};
	Slave s = new Slave(myCompute.describeInstance(slaveInstancesId[i]),
						"slave_"+i,slaveArgs);
	s.start();
}
@endcode

During the execution, you can suspend and resume instances:
@code
waitFor(150);
Msg.info("Suspending " + slaveInstancesId[0]);
myCompute.suspendInstance(slaveInstancesId[0]);
waitFor(200);
Msg.info("Resuming " + slaveInstancesId[0]);
myCompute.resumeInstance(slaveInstancesId[0]);
@endcode

Finally, you can terminate instances one by one:
@code
myCompute.terminateInstance(oneInstanceId);
@endcode

Then, you have to terminate SchIaaS to clean-up the simulation:
@code
SchIaaS.terminate();
@endcode
Please note that this will also terminate all the instances that are still running.

@subsubsection tutorial_data Data management

You can also manipulate some data:
@code
Storage myStorage = SchIaaS.getCloud("myCloud").getStorage("myStorage");

Data someData = new Data("someData", 1e9);

Msg.info("Store some data");
myStorage.put(someData);

Msg.info("Check whether the data transfer is complete: " +
		myStorage.isTransferComplete("someData"));

Msg.info("Retrieve some stored data");
someData = myStorage.get("someData");

Msg.info("Retrieve some data that has not been stored");
Data unstoredData = new Data("unstoredData", 2e9);
someData = myStorage.get(unstoredData);

Msg.info("List the stored data");
Map <String, Data> storedData = myStorage.list(); 	//1st way
myStorage.ls();										//2d way

Msg.info("Delete some data");
myStorage.delete("someData");
@endcode


@subsubsection tutorial_reports Reports

And last, you can obtain cloud usage report by modifying Masterslave.java:
@code
/* execute the simulation */
Msg.run();        

/* print cloud reports */
Msg.info("Cloud details\n");
for (Cloud cloud : SchIaaS.getClouds())  {
	Msg.info("Cloud:"+cloud.getId());
	for (Instance instance : cloud.getCompute().describeInstances()) {
		Msg.info(" - "+instance);
	}
}
@endcode



@subsection tutorial_compiling_running Compiling and Running the Example

@subsubsection tutorial_compiling Compiling the cloudmasterslave example

- First, make sure you can access *simgrid.jar*. 
  We advise to set $SIMGRID_JAVA_ROOT to the directory where *simgrid.jar* has been installed.
  We assume here 
  @code
  $ export SIMGRID_JAVA_ROOT=/usr/local/simgrid/java
  @endcode

- Second, let us compile the source files and direct the resulting class files to the *bin/* directory. 
The source Java files are located in *schiaas/examples/cloudmasterslave*
Let us make *schiaas/examples* our current working directory.
@code
 $ cd examples
 $ javac -d ../bin/ -cp /usr/local/simgrid/java/simgrid.jar:../bin/schiaas.jar cloudmasterslave/*.java
@endcode

- Then make a jar of the class files:
@code
 $ cd ../bin
 $ jar cvf cloudmasterslave.jar cloudmasterslave/*.class 
@endcode

@subsubsection tutorial_running Running the cloudmasterslave example

- You are now ready to run the example. 
  For convenience, you can copy the configuration files to the current directory.
@code
$ cp ../examples/cloudmasterslave/companionFiles/{platform,deploy,cloud}.xml .
$ java -cp $SIMGRID_JAVA_ROOT/simgrid.jar:schiaas.jar:cloudmasterslave.jar cloudmasterslave.Masterslave platform.xml deploy.xml cloud.xml
@endcode

*/
