/*!  
@page howto_scheduler_intro How to study schedulers

This tutorial presents how to study one or several VM to PM schedulers. 
Those schedulers decide which physical machine (PM) should host the vitual machines (VM). The objective can be very different: balance the resources usage, keep room for future VMs, or lower the energy consumption. 

Studying schedulers is mandatory, for instance, when:
- the designer of a new scheduler wants to compare it against other ones;
- an administrator has to choose a scheduler for a cloud platform;
- an administrator has to tune one scheduler for a cloud platform...


@section howto_scheduler_build Building the simulator

The first step is to build the simulator to support your study.

@subsection howto_scheduler_build_impl Implementing the scheduler

Implementing a scheduler is done by extending the <a href="./javadoc/schiaas/org/simgrid/schiaas/engine/compute/ComputeScheduler.html">ComputeScheduler</a> abstract class. 

Provided in SCHIaaS, there are two basic schedulers, that can be used as examples.

- <a href="./javadoc/schiaas/org/simgrid/schiaas/engine/compute/scheduler/simplescheduler/SimpleScheduler.html">SimpleScheduler</a>, a weight-based scheduler supporting two types of objectives: *balancer* to balance the VM among the PM (default openstack behavior); *consolidator* to concentrate the VM among as few PM as possible.

- <a href="./javadoc/schiaas/org/simgrid/schiaas/engine/compute/scheduler/simplescheduler/SimpleReconfigurator.html">SimpleReconfigurator</a>, does the same as *SimpleScheduler*, but reconfigures the placement along the time by migrating one VM to a better place, every *delay* seconds.

Once the schedulers to be studied are implemented, the simulator needs a cloud application to load the simulated platform (i.e. start and stop VM, and change their loads).


@subsection howto_scheduler_build_app Simulating the loads

Any SCHIaaS application can be used to induced loads into the simulation, for instance the basic *MasterSlave* example. If the study concerns scientific computing, looking at \ref simschlouder might be a good idea.

However, the most efficient application might be *loadinjector.SimpleInjection* (that can be found in the examples directory).

Its only purpose is to run injectors, as decribed by the <a href="./javadoc/schiaas/org/simgrid/schiaas/loadinjector/AbstractInjector.html">AbstractInjector</a> abstract class. Injectors are processes that start and stop VM, and change their load along time. 

Provided with SCHIaaS is the *SinInjector*, which injects sinusoïd loads, according to min and max values, and period of the sinusoïd, for both amount of VM and VM CPU load. It is a good example for designing more complex injectors.

The *loadinjector.SimpleInjection* simulator needs four arguments: *platform.xml deploy.xml cloud.xml injector.xml*, that is the same as any SCHIaaS simulator, plus the configuration of the the injector, which looks like this:
@code
<?xml version='1.0'?>
 <!DOCTYPE injectors>
 <injectors>
  <injector id="myInjectorSlow"
   class="org.simgrid.schiaas.loadinjector.injectors.SinInjector"
   cloud="myCloud">
	 	
   <config 
    start_date="0"
    duration="2000"
    period="3"
    instance_period="1000"
    instance_min="10"
    instance_max="192"
    load_period="100"
    load_min="90"
    load_max="100"
    image_id="myImage"
    instance_type_id="small-dp30"
   />
  </injector> 
 </injectors>
@endcode

Please look at <a href="./javadoc/schiaas/index.html">SinInjector javadoc</a> for details.


@subsection howto_scheduler_build_jar Making the simulator

A this stage, you should have a simulator, able to use your scheduler as well as any other scheduler, and an application that loads the cloud.

It is recommended to build jar files of your simulator, to ease its executions in the next steps.


@section howto_scheduler_running Running the simulations

In the following, we will use *loadinjector.SimpleInjection* and compare 5 schedulers:
- *SimpleScheduler* whith type *balancer*;
- *SimpleScheduler* whith type *consolidator*;
- *SimpleReconfigurator* whith type *consolidator* and delay *0*;
- *SimpleReconfigurator* whith type *consolidator* and delay *10*;
- *SimpleReconfigurator* whith type *consolidator* and delay *100*;

NB: The last three schedulers show how this can be used to tune a scheduler. The *delay* is the time (in s.) between two VM migrations.

Please make sure to set the *CLASSPATH* var in order to make the simulator runnable by:
@code
$ java loadinjector.SimpleInjection platform.xml deploy.xml cloud.xml injector.xml
@endcode 

The study will use **the lab** provided with SCHIaaS (see \ref lab_lab).


@subsection howto_scheduler_running_setup Setting up the lab

@subsubsection howto_scheduler_running_setup_sim Configuration of the simulator

To setup the lab:
- create a directory in ./lab/setup, for instance ./lab/setup/cmp-scheduler;
- put the files needed by the simulator in this directory, that is 
  - platform.xml deploy.xml injector.xml, that are common to all simulations;
  - different versions of cloud.xml, to specify the studied schedulers:
    - cloud-balancer.xml
@code
<scheduler name="org.simgrid.schiaas.engine.compute.scheduler.simplescheduler.SimpleScheduler"
		type="balancer"/>
@endcode    
    - cloud-balancer.xml
@code
<scheduler name="org.simgrid.schiaas.engine.compute.scheduler.simplescheduler.SimpleScheduler"
		type="consolidator"/>
@endcode    
    - cloud-reconsolidator0.xml
@code
<scheduler name="org.simgrid.schiaas.engine.compute.scheduler.simplescheduler.SimpleReconfigurator"
		type="consolidator"
		controller="controller"
		delay="0"/>
@endcode    
    - cloud-reconsolidator10.xml
@code
<scheduler name="org.simgrid.schiaas.engine.compute.scheduler.simplescheduler.SimpleReconfigurator"
		type="consolidator"
		controller="controller"
		delay="10"/>
@endcode    
    - cloud-reconsolidator0.xml
@code
<scheduler name="org.simgrid.schiaas.engine.compute.scheduler.simplescheduler.SimpleReconfigurator"
		type="consolidator"
		controller="controller"
		delay="100"/>
@endcode    

NB: *controller* indicates which host to use to run the scheduler processes.



@subsubsection howto_scheduler_running_setup_cfg Configuration of the lab

The following file *cmp-schedulers.cfg* describes the simulations to run:
@code
#SETUP_DIR ./setup/cmp-scheduler
#JAVA_START_ARGS loadinjector.SimpleInjection
#JAVA_START_ARGS platform.xml deploy.xml
#JAVA_END_ARGS injector.xml

balancer: cloud-balancer.xml
consolidator: cloud-consolidator.xml
reconsolidator0: cloud-reconsolidator0.xml
reconsolidator10: cloud-reconsolidator10.xml
reconsolidator100: cloud-reconsolidator100.xml
@endcode
where:
- SETUP_DIR is the location of the files;
- JAVA_*_ARGS are the arguments common to all simulations;
- [simulation_id]:[arguments] describe one unique simulation by id and specific arguments.

Afterward, the simulations can be ran using:
@code
./lab -p 2 setup/cmp-scheduler/cmp-scheduler.cfg 
@endcode

This will execute:
@code
java loadinjector.SimpleInjection platform.xml deploy.xml cloud-balancer.xml injector.xml
java loadinjector.SimpleInjection platform.xml deploy.xml cloud-consolidator.xml injector.xml
java loadinjector.SimpleInjection platform.xml deploy.xml cloud-reconsolidator0.xml injector.xml
java loadinjector.SimpleInjection platform.xml deploy.xml cloud-reconsolidator10.xml injector.xml
java loadinjector.SimpleInjection platform.xml deploy.xml cloud-reconsolidator100.xml injector.xml
@endcode

NB: -p 2 makes 2 simulations to run in parallel.

This will then create subdirectories in the directory *simulations*, according to the ids given in the configuration file:

@code
$ ls -R simulations/

simulations/:
balancer  consolidator  reconsolidator0  reconsolidator10  reconsolidator100

simulations/balancer:
schiaas.trace  simgrid.out

simulations/consolidator:
schiaas.trace  simgrid.out

simulations/reconsolidator0:
schiaas.trace  simgrid.out

simulations/reconsolidator10:
schiaas.trace  simgrid.out

simulations/reconsolidator100:
schiaas.trace  simgrid.out
@endcode

@section howto_scheduler_observing Observing the simulations

This section shows how the results of these simulations can be observed.

@subsection howto_scheduler_observing_series Identifying the observations

First of all, let's identify what can be observed, using ./bin/trace-util.py.

@code
$ ./trace-util.py simulations/balancer/schiaas.trace --info -d

{
  "root": {
    "date": "property: Clock of the simulation in s",
    "description": "property: Description if the entity",
    "cloud": {
      "myCloud": {
        "compute": {
          "image_caching": "property: Type of caching of VM images",
          "inter_boot_delay": "property: Delay between two VM boots on the same host",
          "engine": "property: SCHIaaS engine",
          "image_storage": "property: Storage used for VM images",
          "controller": "property: Host used as controller for the entity",
          "compute_host": {
            ".*": {
              "cores": "property: Number of cores of the entity",
              "ram_size": "property: SimGrid's VM property",
              "diskSize": "property: Size of disk in MB",
              "used_cores": "event: Number of cores in use"
            }
          },
          "instances": {
            ".*": {
              "image": "property: VM image",
              "instance_type": "property: Type of instance",
              "command": "event: User command issued regarding the entity",
              "load": "event: CPU load",
              "schedule": "event: Host to which the instance is scheduled"
            }
          },
          "scheduler": {
            "name": "property:  Name of the entity",
            "controller": "property: Host used as controller for the entity",
            "type": "property:  Type of the entity"
          }
        }
      }
    },
    "injector": {
      "myInjectorSlow": {
        "injector": "property:  Class of injector",
        "random_seed": "property:  Seed used to randomize the entity",
        "instances_count": "event:  Number of instances",
        "instances_load": "event:  CPU load"
      }
    },
    "vm": {
      ".*": {
        "n_cores": "property: SimGrid's VM property",
        "ram_size": "property: SimGrid's VM property",
        "net_cap": "property: SimGrid's VM property",
        "disk_path": "property: SimGrid's VM property",
        "disk_size": "property: SimGrid's VM property",
        "mig_net_speed": "property: SimGrid's VM property",
        "dp_intensity": "property: SimGrid's VM property",
        "cpu_bound": "event: SimGrid's VM property",
        "state": "event: State of the entity"
      }
    }
  }
}
@endcode


@subsection howto_scheduler_observing_loads Observing the injection

Then, let's observe the injection: these are the events *instances_count* in the injector section. 

The format is always [entity] [date] [value].

One can simply use grep:
@code
$ cat simulations/balancer/schiaas.trace | grep instances_count 

root:injector:myInjector:instances_count	0.0	101
root:injector:myInjector:instances_count	10.0	102
root:injector:myInjector:instances_count	20.0	103
root:injector:myInjector:instances_count	30.0	104
...
@endcode

Or trace-util.py:
@code
$ ./bin/trace-util.py simulations/balancer/schiaas.trace --event instances_count
entity	date	value

root:injector:myInjector:instances_count	0.0	101
root:injector:myInjector:instances_count	10.0	102
root:injector:myInjector:instances_count	20.0	103
root:injector:myInjector:instances_count	30.0	104
...
@endcode

Such observations can be automatized by adding the following line to *cmp-scheduler.cfg*:
@code
#R_SCRIPT template.R
#TU_ARGS --event instances_count 
@endcode
and a file template.R in the setup directory, with this content:
@code
source('reads.R')
pdf('data.pdf')
source('plots.R')
dev.off()
@endcode

Afterward, running the lab
@code
./lab -k setup/cmp-scheduler/cmp-scheduler.cfg 
@endcode
NB: -k allows to keep the results of previous simulations.

This will create files in the directory ./data: [simulation_id].instances_count.dat and plot their content using R into ./data/data.pdf:

\image html balancer.instances_count.png

To check the effect of this injection on the cloud, one can count the virtual machines that are in the running state:
@code
#TU_ARGS --count_if vm.*state eq running
@endcode

\image html balancer.vm__state_eq_running.png


Alternatively, one can plot the states of the vms:
@code
#TU_ARGS --grep vm.*state
@endcode

\image html balancer.vm__state.png

Please note the black area at the left of the figure: those are the names of the vms. They are not correctly plotted because of the large number of vms. 
Be aware that the objective of the lab is not to produce ready-to-publish plots, but only to provide efficient tools to quickly mine simulations data.

@subsection howto_scheduler_observing_usage Observing the usage of hosts

To observe the behavior of the scheduler, let's look at the number of cores used by VM on each host:
@code
#TU_ARGS --event used_cores
@endcode

With balancer, the vm are well spread among the hosts:
\image html balancer.used_cores.png

With consolidator, there is some heterogenity in the number of used cores at a given date, especialy when the load change:
\image html consolidator.used_cores.png

With reconsolidator, this heterogenity is maximized all along the simulation:
\image html reconsolidator0.used_cores.png


@subsection howto_scheduler_observing_green Observing how many hosts are idle

For green purpose, one may want to shut hosts down. Thus, many schedulers aim at minimizing the number of busy physical hosts.

Let's count the number of busy hosts, that is hosts not having 0 used cores:

@code
#TU_ARGS --count_if used_cores ne 0
@endcode

\image html balancer.used_cores_ne_0.png
\image html consolidator.used_cores_ne_0.png
\image html reconsolidator0.used_cores_ne_0.png
\image html reconsolidator10.used_cores_ne_0.png
\image html reconsolidator100.used_cores_ne_0.png

Or alternatively, the number of idle hosts, those that could be shut down:
@code
#TU_ARGS --count_if used_cores eq 0
@endcode

\image html balancer.used_cores_eq_0.png
\image html consolidator.used_cores_eq_0.png
\image html reconsolidator0.used_cores_eq_0.png
\image html reconsolidator10.used_cores_eq_0.png
\image html reconsolidator100.used_cores_eq_0.png

All in all, the static schedulers perform poorly when it comes to shut hosts down, and the reconfigurator performs very well, especially with a short delay.

@subsection howto_scheduler_observing_migrations Observing the migrations

However, reconfigurations imply VM migrations, that consume resources as well.
Let's look at the amount of migrations:
@code
#TU_ARGS --count_if vm.*state eq migrating
@endcode

\image html reconsolidator0.vm__state_eq_migrating.png
\image html reconsolidator10.vm__state_eq_migrating.png
\image html reconsolidator100.vm__state_eq_migrating.png

As one can see, with a delay of 0 seconds, there are up to 6 concurrent migrations, while with a delay of 10 secondes, only two migrations occured concurrently.


@subsection howto_scheduler_observing_dual_injections Using two injectors at once.

After the previous observations, the reconsolidator scheduler seems interresting, particularly with a short delay.

Let's look at the results with a different load.
To do so, one can add another injector configuration file *injector-fast.xml* and add the simulations in the lab

@code 
<?xml version='1.0'?>
<!DOCTYPE injectors>
<injectors>
 </injector> 
  <injector id="myInjectorFast"
   class="org.simgrid.schiaas.loadinjector.injectors.SinInjector"
   cloud="myCloud">
  <config 
   start_date="0"
   duration="2000"
   period="3"
   instance_period="60"
   instance_min="128"
   instance_max="192"
   load_period="100"
   load_min="90"
   load_max="100"
   image_id="myImage"
   instance_type_id="small-dp30"
  />
 </injector> 
</injectors>
@endcode

@code
balancer: cloud-balancer.xml injector.xml
consolidator: cloud-consolidator.xml injector.xml
reconsolidator0: cloud-reconsolidator0.xml injector.xml
reconsolidator10: cloud-reconsolidator10.xml injector.xml
reconsolidator100: cloud-reconsolidator100.xml injector.xml
balancer-fast: cloud-balancer.xml injector-fast.xml
consolidator-fast: cloud-consolidator.xml injector-fast.xml
reconsolidator0-fast: cloud-reconsolidator0.xml injector-fast.xml
reconsolidator10-fast: cloud-reconsolidator10.xml injector-fast.xml
reconsolidator100-fast: cloud-reconsolidator100.xml injector-fast.xml
@endcode


Or alternatively, one can combine the two injections into one simulation with *injector-slowfast.xml*.

@code 
<?xml version='1.0'?>
<!DOCTYPE injectors>
<injectors>

 <injector id="myInjectorSlow"
  class="org.simgrid.schiaas.loadinjector.injectors.SinInjector"
  cloud="myCloud">
  <config 
   start_date="0"
   duration="2000"
   period="3"
   instance_period="1000"
   instance_min="10"
   instance_max="192"
   load_period="100"
   load_min="90"
   load_max="100"
   image_id="myImage"
   instance_type_id="small-dp30"
  />
 </injector> 

 <injector id="myInjectorFast"
   class="org.simgrid.schiaas.loadinjector.injectors.SinInjector"
   cloud="myCloud">
  <config 
   start_date="2000"
   duration="2000"
   period="3"
   instance_period="60"
   instance_min="128"
   instance_max="192"
   load_period="100"
   load_min="90"
   load_max="100"
   image_id="myImage"
   instance_type_id="small-dp30"
  />
 </injector> 

</injectors>
@endcode

@code
balancer-slowfast: cloud-balancer.xml injector-slowfast.xml
consolidator-slowfast: cloud-consolidator.xml injector-slowfast.xml
reconsolidator0-slowfast: cloud-reconsolidator0.xml injector-slowfast.xml
reconsolidator10-slowfast: cloud-reconsolidator10.xml injector-slowfast.xml
reconsolidator100-slowfast: cloud-reconsolidator100.xml injector-slowfast.xml
@endcode

As one can see, following the previous injection, there is now a second injection with a much more agressive *intance_period*. This simulate a large number of users creating and terminating VM all the time:
\image html balancer_slowfast.instances_count.png

Now, let's look at the number of busy hosts with reconsolidator 0 and 10 :
\image html reconsolidator0_slowfast.used_cores_ne_0.png
\image html reconsolidator10_slowfast.used_cores_ne_0.png

Under agressive loads, those actually perform worse than the simple consolidator:
\image html consolidator_slowfast.used_cores_ne_0.png

This is confirmed by the integrals of the number of busy hosts over time:
\image html busy_hosts-integral-slow.png
\image html busy_hosts-integral-fast.png


This is explained by the amount of migrations that slow the platform and prevent from shutting the VM down as soon as the user ask for it:

\image html reconsolidator0_slowfast.vm__state_eq_migrating.png
\image html reconsolidator10_slowfast.vm__state_eq_migrating.png
\image html reconsolidator100_slowfast.vm__state_eq_migrating.png


@subsection howto_scheduler_observing_closely Observing more closely

As raw data from observations are not sufficient, data can be easily imported into R:
@code
$ R
> source('data/reads.R')
@endcode

Afterward, the observations can be manipulated directly:
@code 
> head(balancer.used_cores_ne_0)
      entity     date value
1 used_cores   0.0000    24
2 used_cores 543.0078    23
3 used_cores 588.0078    22
4 used_cores 591.0078    21
5 used_cores 597.0078    20
6 used_cores 600.0078    19
@endcode

Some additional functionalities are available in the library traceutil.
For instance, it allows to integrate values of the observation over time, and apply a given function to all observed XPs at once:
@code
> install('bin/traceutil')
> ??traceutil
>
> ?tu_integrate
> tu_integrate(balancer.used_cores_ne_0)
[1] 85847.87
> 
> xps
                 xp
1          balancer
2      consolidator
3   reconsolidator0
4  reconsolidator10
5 reconsolidator100
> 
> ?tu_apply
> tu_apply(xps,'used_cores_ne_0', tu_integrate)
                           xp
1                    balancer
2               balancer_fast
3           balancer_slowfast
4                consolidator
5           consolidator_fast
6       consolidator_slowfast
7             reconsolidator0
8        reconsolidator0_fast
9    reconsolidator0_slowfast
10          reconsolidator100
11     reconsolidator100_fast
12 reconsolidator100_slowfast
13           reconsolidator10
14      reconsolidator10_fast
15  reconsolidator10_slowfast
@endcode

And everything can be automatized with template.R, as declared in the lab configuration file:
@code
library(traceutil)

pdf('data.pdf')
tu_read(plotting=TRUE)
dev.off()


pdf('busy_hosts-integral.pdf')
uc <-tu_apply(xps,'used_cores_ne_0',tu_integrate)
barplot(uc$value, names.arg=uc$xp)
uc
dev.off()
@endcode

After running lab.sh:
- *data/R.out* will contain the result of the execution of R;
- *data/data.pdf* will contain the plot of every observation;
- *data/busy_hosts-integral.pdf* will contain the specific plot:


For more details please see \ref lab and \ref lab_setup_observing.


@section howto_scheduler_conclusion Conclusion

All files of this tutorial are available and all results can obtained by
@code
./lab.sh -p 2 setup/cmp-scheduler/cmp-schedulers.cfg 
@endcode

And most importantly: feel free to contact us for any purpose, and you are very welcome to contribute to the project by providing you own schedulers and injectors.
We will be pleased to include them as a part of the distribution.

*/